# This script takes the datafiles generated by the script at
# `timing/traintest_timing_data.R` and then analyzes them using the glfBLUP model.
# The runtimes of the different components of the prediction pipeline are measured
# and saved.
#
# Note that this scripts only performs timing measurements.
# The timing results are not perfectly reproducible and obviously depend on hardware.

start <- Sys.time()

# Loading libraries:
library(rlist)
library(tictoc)
library(glfBLUP)

# Setting seed:
set.seed(1997)

# Total number of secondary features:
ps <- seq(100, 2500, 100)

# Loading kinship:
load("genotypes/K_sim.RData"); rm(M)

# Setting up timing result storage:
runs.warmup <- 1
runs.timing <- 5
steps <- c("Redundancy filtering",
           "Genetic regularization",
           "Residual regularization",
           "Factor model",
           "Factor scores",
           "Subset selection",
           "glfBLUP genomic prediction",
           "Other")

results <- expand.grid(Step = steps, Run = 1:runs.timing, p = ps)
results$Duration <- numeric(nrow(results))

result.row.start <- 1
result.row.end <- length(steps)
p <- ps[1]
for (p in ps) {
  
  # Warmup =====================================================================
  run.warmup <- 1
  for (run.warmup in 1:runs.warmup) {
    
    # Loading simulated dataset:
    datalist <- list.load(file = sprintf("timing/datasets/timing_p%d.RData", p))
  
    # Storing data and prediction target:
    d <- datalist$data.real
    pred.target <- datalist$pred.target
    d[which(is.na(d$Y)), 2:ncol(d)] <- NA
    
    tic("Full model") # Full model start
    
    
    
    ## 1. Make training data and store feature/focal trait names ===============
    d.train <- droplevels(na.omit(d))
    sec <- names(d[2:(ncol(d) - 1)])
    foc <- names(d)[ncol(d)]
    
    
    
    ## 2. Mock redundancy filtering the sec. features using training data ======
    tic("Redundancy filtering") # Redundancy filtering start
    temp <- glfBLUP::redundancyFilter(data = d.train[c("G", sec)], tau = 0.95, verbose = F)
    toc(log = FALSE) # Redundancy filtering stop
    
    
    
    ## 3. Regularization =======================================================
    folds <- glfBLUP::createFolds(genos = unique(as.character(d.train$G)))
    
    tic("Genetic Regularization") # Genetic regularization start
    tempG <- glfBLUP::regularizedCorrelation(data = d.train[c("G", sec)],
                                            folds = folds, what = "genetic", dopar = TRUE)
    toc(log = FALSE) # Genetic regularization stop
    
    tic("Residual Regularization") # Residual regularization start
    tempE <- glfBLUP::regularizedCorrelation(data = d.train[c("G", sec)],
                                            folds = folds, what = "residual", dopar = TRUE)
    toc(log = FALSE) # Residual regularization stop
    
    Rg.reg <- tempG$optCor
    
    
    
    ## 4. Fitting factor model =================================================
    tic("Factor model") # Factor model start
    FM.fit <- glfBLUP::factorModel(data = d.train[c("G", sec)], cormat = Rg.reg, what = "genetic")
    toc(log = FALSE) # Factor model stop
    
    
    
    ## 5. Getting factor scores (also for the test set in CV2!) ================
    tic("Factor scores") # Factor scores start
    D <- sqrt(diag(tempG$Sg)) 
    L.cov <- diag(D) %*% FM.fit$loadings
    PSI.cov <- outer(D, D) * FM.fit$uniquenesses
    
    # CV1 Factor scores
    CV1.F.scores <- glfBLUP::factorScores(data = d[c("G", sec)],
                                         loadings = L.cov,
                                         uniquenesses = PSI.cov,
                                         m = FM.fit$m,
                                         type = "genetic-thomson-repdiv",
                                         Se = outer(sqrt(diag(tempE$Se)), sqrt(diag(tempE$Se))) * tempE$optCor)
    
    CV1.d.final <- cbind(CV1.F.scores, d$Y)
    names(CV1.d.final)[ncol(CV1.d.final)] <- "Y"
    names(CV1.d.final)[1] <- "G"
    toc(log = FALSE) # Factor scores stop
    
    
    
    ## 6. Selecting the relevant factors =======================================
    tic("Subset selection") # Subset selection start
    # Subset selection can only be done using training data:
    selection <- glfBLUP::factorSelect(na.omit(CV1.d.final), procedure = "leaps", verbose = F)
    toc(log = FALSE) # Subset selection stop
    
    
    
    ## 7. Multi-trait genomic prediction =======================================
    tic("glfBLUP genomic prediction") # glfBLUP genomic prediction start
    CV1.temp <- glfBLUP::glfBLUP(data = CV1.d.final, selection = selection, K = K, sepExp = FALSE, verbose = F)
    toc(log = FALSE) # glfBLUP genomic prediction stop
    
    toc(log = FALSE) # Full model stop
    
    cat(sprintf("Warmup run %d done, accuracy of %.3f\n\n",
                run.warmup, cor(pred.target, CV1.temp$preds[match(names(pred.target), names(CV1.temp$preds))])))
    
  }
  
  cat(sprintf("Proceeding to timing runs for p = %s\n\n", p))
  
  # Timing =====================================================================
  run.timing <- 1
  for (run.timing in 1:runs.timing) {
    
    # Loading simulated dataset:
    datalist <- list.load(file = sprintf("timing/datasets/timing_p%d.RData", p))
    
    # Storing data and prediction target:
    d <- datalist$data.real
    pred.target <- datalist$pred.target
    d[which(is.na(d$Y)), 2:ncol(d)] <- NA
    
    tic("Full model") # Full model start
    
    ## 1. Make training data and store feature/focal trait names ===============
    d.train <- droplevels(na.omit(d))
    sec <- names(d[2:(ncol(d) - 1)])
    foc <- names(d)[ncol(d)]
    
    
    
    ## 2. Mock redundancy filtering the sec. features using training data ======
    tic("Redundancy filtering") # Redundancy filtering start
    temp <- glfBLUP::redundancyFilter(data = d.train[c("G", sec)], tau = 0.95, verbose = F)
    toc(log = TRUE) # Redundancy filtering stop
    
    
    
    ## 3. Regularization =======================================================
    folds <- glfBLUP::createFolds(genos = unique(as.character(d.train$G)))
    
    tic("Genetic Regularization") # Genetic regularization start
    tempG <- glfBLUP::regularizedCorrelation(data = d.train[c("G", sec)],
                                            folds = folds, what = "genetic", dopar = TRUE)
    toc(log = TRUE) # Genetic regularization stop
    
    tic("Residual Regularization") # Residual regularization start
    tempE <- glfBLUP::regularizedCorrelation(data = d.train[c("G", sec)],
                                            folds = folds, what = "residual", dopar = TRUE)
    toc(log = TRUE) # Residual regularization stop
    
    Rg.reg <- tempG$optCor

    
    
    ## 4. Fitting factor model =================================================
    tic("Factor model") # Factor model start
    FM.fit <- glfBLUP::factorModel(data = d.train[c("G", sec)], cormat = Rg.reg, what = "genetic")
    toc(log = TRUE) # Factor model stop
    
    
    
    ## 5. Getting factor scores (also for the test set in CV2!) ================
    tic("Factor scores") # Factor scores start
    D <- sqrt(diag(tempG$Sg)) 
    L.cov <- diag(D) %*% FM.fit$loadings
    PSI.cov <- outer(D, D) * FM.fit$uniquenesses
    
    # CV1 Factor scores
    CV1.F.scores <- glfBLUP::factorScores(data = d[c("G", sec)],
                                         loadings = L.cov,
                                         uniquenesses = PSI.cov,
                                         m = FM.fit$m,
                                         type = "genetic-thomson-repdiv",
                                         Se = outer(sqrt(diag(tempE$Se)), sqrt(diag(tempE$Se))) * tempE$optCor)
    
    CV1.d.final <- cbind(CV1.F.scores, d$Y)
    names(CV1.d.final)[ncol(CV1.d.final)] <- "Y"
    names(CV1.d.final)[1] <- "G"
    toc(log = TRUE) # Factor scores stop
    
    
    
    ## 6. Selecting the relevant factors =======================================
    tic("Subset selection") # Subset selection start
    # Subset selection can only be done using training data:
    selection <- glfBLUP::factorSelect(na.omit(CV1.d.final), procedure = "leaps", verbose = F)
    toc(log = TRUE) # Subset selection stop
    
    
    
    ## 7. Multi-trait genomic prediction =======================================
    tic("glfBLUP genomic prediction") # glfBLUP genomic prediction start
    CV1.temp <- glfBLUP::glfBLUP(data = CV1.d.final, selection = selection, K = K, sepExp = FALSE, verbose = F)
    toc(log = TRUE) # glfBLUP genomic prediction stop
    
    toc(log = TRUE) # Full model stop
    
    cat(sprintf("Timing run %d done, accuracy of %.3f\n\n",
                run.timing, cor(pred.target, CV1.temp$preds[match(names(pred.target), names(CV1.temp$preds))])))
    
    times <- tic.log(format = FALSE)
    tic.clearlog()
    times <- unlist(lapply(times, function(x) x$toc - x$tic))
    names(times) <- steps
    times["Other"] <- times["Other"] - sum(times[1:7])
    
    results[result.row.start:result.row.end, "Duration"] <- as.numeric(times)
    result.row.start <- result.row.end + 1
    result.row.end <- result.row.start + 7
  }
  cat(sprintf("Timing runs for p = %s done, proceeding to warmup of next p\n\n", p))
}

# Saving results:
write.csv(results, "timing/timing.csv")

end <- Sys.time()
end - start
